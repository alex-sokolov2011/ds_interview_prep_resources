answer_id,question_id,answer_text,is_correct
1,1,"Операция UNION возвращает только уникальные записи из результирующего набора данных, а UNION ALL вернет все строки, даже если одна или несколько строк дублируются друг с другом",True
2,1,"Операция UNION возвращает все строки, даже если одна или несколько строк дублируются друг с другом, а UNION ALL возвращает только уникальные записи.",False
3,1,Операция UNION и UNION ALL эквивалентны и возвращают одинаковые результаты.,False
4,1,"Операция UNION быстрее, чем UNION ALL, так как не проверяет на дубликаты.",False
5,2,"AND имеет больший приоритет, нежели OR.",True
6,2,"OR имеет больший приоритет, нежели AND.",False
7,2,AND и OR имеют одинаковый приоритет.,False
8,2,Приоритет операторов зависит от контекста запроса.,False
9,4,"5, потому что подсчитаются все строки таблицы независимо от их содержания.",True
10,4,"6, потому что подсчитываются ненулевые элементы таблицы",False
11,4,"4, потому что подсчитываются нулевые элементы таблицы.",False
12,4,"2, потому что запрос не учитывает строки с null значениями.",False
13,6,"5, COUNT(1) работает так же, как COUNT(*) — он считает все строки в таблице, даже если в них есть NULL",True
14,6,"1, потому что подсчитываются элементы таблицы равные 1",False
15,6,"3, потому что подсчитываются ненулевые элементы таблицы которые встречаются в таблице один раз {1,3,5)",False
16,6,"2, потому что запрос подсчитывает строки без null значений",False
17,7,"3, COUNT(id1) считает только строки, где значения в столбце id1 не NULL",True
18,7,"5, потому что COUNT(id1) считает все строки таблицы в столбце id1 в том числе NULL",False
19,7,"Ошибку, потому что согласно синтаксису должно быть COUNT(`id1`) ",False
20,7,"2, потому что COUNT(id1) учитывает только строки с значениями не NULL в обоих столбцах",False
25,9,"5, потому что COUNT(expression) считает количество НЕ NULL значений, а 'id1' - строковая константа и она всегда НЕ NULL. PostgreSQL не интерпретирует строковый литерал как имя столбца",True
26,9,"3, потому что COUNT(column)	возвращает количество строк, где column IS NOT NULL",False
27,9,"Ошибку, потому что 'id1' не является названием столбца. Необходимо писать просто id1",False
28,9,"Ошибку, потому что 'id1' не является названием столбца. Необходимо писать просто ""id1""",False
29,10,"3, потому что COUNT(expression) считает количество НЕ NULL значений внутри столбца, если задан столбец. PostgreSQL разрешает имена столбцов в двойных кавычках ""id2""",True
30,10,"5, потому что 5, потому что COUNT(expression) считает количество НЕ NULL значений, а ""id2"" - строковая константа и она всегда НЕ NULL. PostgreSQL не разрешает создавать имя столбца в двойных кавычках",False
31,10,"Ошибку, потому что ""id2"" не является названием столбца. Необходимо писать просто id2",False
32,10,"2, потому что COUNT(""id2"") учитывает только строки с NULL значениями",False
33,11,"0, потому что NULL в PostgreSQL не считается значением — это ""отсутствие данных"". COUNT(expression) игнорирует NULL и результат будет 0",True
34,11,"4, потому что COUNT(NULL) тогда считает количество NULL значений в таблице",False
35,11,"3, потому что COUNT(NULL) возвращает количество строк, где column IS NOT NULL",False
36,11,"Ошибку, потому что NULL в PostgreSQL не считается выражением (expression), а COUNT(expression) требует выражение на вход",False
37,12,"2, потому что COUNT(DISTINCT id1) считает количество УНИКАЛЬНЫХ НЕ NULL значений в id1. В таблице это {2, 5}, вторую двуйку {2} в последней строке не учитываем, потому что она уже была выше во второй строке",True
38,12,"0, потому что COUNT(DISTINCT id1) сначала выполняет DISTINCT, а из-зи наличия NULL в столбце операция возвращает NULL. А COUNT(NULL) = 0",False
39,12,"5, потому что COUNT(DISTINCT id1) считает количество всех значений в id1, включая NULL, аналогично COUNT(id1)",False
40,12,"3, потому что COUNT(DISTINCT id1) считает все строки таблицы со значениями НЕ NULL",False
41,13,"Ошибку, PostgreSQL не поддерживает использование COUNT(DISTINCT id1, id2) для подсчета уникальных комбинаций значений в нескольких столбцах. Функция COUNT с несколькими аргументами типа integer не существует",True
42,13,"4, потому что COUNT(DISTINCT id1, id2) считает количество уникальных комбинаций значений в столбцах id1 и id2",False
43,13,"2, потому что COUNT(DISTINCT id1, id2) считает количество уникальных комбинаций значений в столбцах id1 и id2 не учитывая те в которых есть NULL",False
44,13,"2, потому что COUNT(DISTINCT id1, id2) считает количество уникальных комбинаций значений в столбцах id1 и id2 в которых есть NULL",False
45,14,"5, потому что SUM(1) суммирует единицу для каждой строки таблицы, независимо от значений в колонках, потому что эта константа (1) отлична от NULL",True
46,14,"1, потому что SUM(1) просто суммирует единицу как математическая функция",False
47,14,"Ошибку, потому что в SUM(columns) можно использовать только название столбца",False
48,14,"2, SUM(1) суммирует единицу только для строк без значений NULL в обоих столбцах одновременно",False
49,15,"9, потому что SUM(id1) складывает только значения столбца id1 (2, 5, 2), пропуская NULL",True
50,15,"3, потому что SUM(id1) считает кол-во строк столбца id1 (2, 5, 2), пропуская NULL",False
51,15,"0, потому что SUM(id1) при сложении знаяений NULL возвращает 0 как COUNT(NULL)",False
52,15,"7, потому что SUM(id1) складывает только уникальные значения столбца id1, пропуская NULL",False
53,16,"9, потому что SUM(expression) вычисляет сумму значений выражения (id1 + id2), подставляя в него значения из каждой строки, игнорируя NULL которые получаются после сложения {2 + 2 , 2 + 3}. Если в любой из колонок (id1 или id2) в строке есть NULL, то выражение id1 + id2 тоже становится NULL",True
54,16,"15, потому что SUM(expression) вычисляет сумму значений выражения (id1 + id2), подставляя в него значения из каждой строки, включая NULL {1, 2 + 2 , 5, 2 + 3}",False
55,16,"5, потому что SUM(expression) вычисляет сумму значений выражения (id1 + id2), подставляя в него значения из каждой строки, игнорируя строки с NULL. SUM() не считает выражение, если одно из значений NULL",False
56,16,"0, потому что SUM(expression) складывает все значения включая NULL. И как мы знаем, если сложить NULL с любым значением мы получим NULL",False
57,17,"6, потому что SUM(expression) считает сумму по всем НЕ NULL значениям внутри столбца, если задан столбец. PostgreSQL разрешает имена столбцов в двойных кавычках ""id2""",True
58,17,"Ошибку, потому что ""id2"" не является названием столбца. Необходимо писать просто id2",False
59,17,"NULL, потому что SUM(expression) считает сумму по всем значениям внутри столбца, включая NULL {1, 2, NULL, NULL, 3}. А как мы знаем NULL плюс любое значение вернет NULL",False
60,17,"0, потому что SUM(expression) считает сумму по всем значениям внутри столбца, включая NULL {1, 2, NULL, NULL, 3}. А как мы знаем NULL плюс любое значение вернет NULL. А SUM(NULL) как и COUNT(NULL) вернет 0",False
61,18,"Ошибку, потому что PostgreSQL не поддерживает использование SUM(id1, id2) для подсчета значений в нескольких столбцах. Функция SUM с несколькими аргументами типа integer не существует",True
62,18,"15, потому что SUM(id1, id2) суммирует значения обоих столбцов",False
63,18,"9, потому что SUM(id1, id2) суммирует значения обоих столбцов, игнорируя NULL",False
64,18,"0, потому что SUM(id1, id2) считает сумму по всем значениям внутри заданных столбцов, включая NULL. А как мы знаем NULL плюс любое значение вернет NULL. А SUM(NULL) как и COUNT(NULL) вернет 0",False
65,19,"Ошибку, потому что PostgreSQL не поддерживает использование SUM(DISTINCT id1, id2) для подсчета значений в нескольких столбцах. Функция SUM с несколькими аргументами типа integer не существует. Агрегатные функции принимают один аргумент и возвращают одно значение, вычисленное на основе набора входных значений из строк",True
66,19,"7, потому что SUM(DISTINCT id1, id2) суммирует уникальные значения обоих столбцов. Задублированное значение {2, 2} в пятой строке не попадет в подсчет суммы",False
67,19,"9, потому что SUM(DISTINCT id1, id2) суммирует уникальные значения обоих столбцов, игнорируя NULL {2, 2, 2, 3}",False
68,19,"0, потому что SUM(DISTINCT id1, id2) считает сумму по всем уникальным значениям внутри заданных столбцов, включая NULL. А как мы знаем NULL плюс любое значение вернет NULL. А SUM(NULL) как и COUNT(NULL) вернет 0",False
69,20,"1. FROM       -- указание источника данных
2. WHERE      -- фильтрация данных
3. GROUP BY   -- группировка данных
4. HAVING     -- фильтрация данных после группировки
5. SELECT     -- перечисление полей результирующей таблицы
6. ORDER BY   -- сортировка результирующей таблицы
7. LIMIT      -- ограничение количества выводимых записей
8. OFFSET     -- пропуск определенного количества строк перед началом вывода",True
70,20,"1. SELECT     -- перечисление полей результирующей таблицы
2. FROM       -- указание источника данных
3. WHERE      -- фильтрация данных
4. GROUP BY   -- группировка данных
5. HAVING     -- фильтрация данных после группировки
6. ORDER BY   -- сортировка результирующей таблицы
7. LIMIT      -- ограничение количества выводимых записей
8. OFFSET     -- пропуск определенного количества строк перед началом вывода",False
71,20,"1. FROM       -- указание источника данных
2. SELECT     -- перечисление полей результирующей таблицы
3. WHERE      -- фильтрация данных
4. GROUP BY   -- группировка данных
5. HAVING     -- фильтрация данных после группировки
6. ORDER BY   -- сортировка результирующей таблицы
7. LIMIT      -- ограничение количества выводимых записей
8. OFFSET     -- пропуск определенного количества строк перед началом вывода",False
72,20,"1. SELECT     -- перечисление полей результирующей таблицы
2. FROM       -- указание источника данных
3. GROUP BY   -- группировка данных
4. WHERE      -- фильтрация данных
5. HAVING     -- фильтрация данных после группировки
6. ORDER BY   -- сортировка результирующей таблицы
7. LIMIT      -- ограничение количества выводимых записей
8. OFFSET     -- пропуск определенного количества строк перед началом вывода",False
73,21,"Ограничения (constraints) — это правила, которые помогают базе данных поддерживать порядок. Они следят, чтобы в таблицы не попадали неправильные или противоречивые данные. 
Ниже самые популярные ограничения: 
PRIMARY KEY — делает столбец (или группу столбцов) уникальным идентификатором каждой строки 
UNIQUE — запрещает дублирующиеся значения в столбце 
NOT NULL — не позволяет хранить пустые (NULL) значения 
DEFAULT — подставляет значение по умолчанию, если ничего не указано 
CHECK — задаёт кастомные условия, например, `age > 0` 
FOREIGN KEY — связывает таблицы, чтобы данные не теряли логику",True
74,21,"Ограничения (constraints) — это правила, которые помогают базе данных поддерживать порядок. Они следят, чтобы в таблицы не попадали неправильные или противоречивые данные. 
Ниже самые популярные ограничения: 
PRIMARY KEY — запрещает дублирующиеся значения в столбце 
UNIQUE — делает столбец (или группу столбцов) уникальным идентификатором каждой строки 
NOT NULL — позволяет хранить пустые (NULL) значения 
DEFAULT — подставляет значение по умолчанию, если ничего не указано 
CHECK — задаёт кастомные условия, например, `age > 0` 
FOREIGN KEY — связывает таблицы, чтобы данные не теряли логику",False
75,21,"Ограничения (constraints) — это правила, которые помогают базе данных поддерживать порядок. Они следят, чтобы в таблицы не попадали неправильные или противоречивые данные. 
Ниже самые популярные ограничения: 
PRIMARY KEY — делает столбец (или группу столбцов) уникальным идентификатором каждой строки 
UNIQUE — запрещает дублирующиеся значения в столбце 
NOT NULL — не позволяет хранить пустые (NULL) значения 
DEFAULT — подставляет значение по умолчанию, если ничего не указано 
CHECK — задаёт кастомные условия, например, `age > 0` 
FOREIGN KEY — запрещает дублирующиеся значения в столбце",False
76,21,"Ограничения (constraints) — это правила, которые помогают базе данных поддерживать порядок. Они следят, чтобы в таблицы не попадали неправильные или противоречивые данные. 
Ниже самые популярные ограничения: 
PRIMARY KEY — делает столбец (или группу столбцов) уникальным идентификатором каждой строки 
UNIQUE — запрещает дублирующиеся значения в столбце 
NOT NULL — не позволяет хранить пустые (NULL) значения 
DEFAULT — проверяет что значение соответствует типу по умолчанию 
CHECK — задаёт кастомные условия, например, `age > 0` 
FOREIGN KEY — связывает таблицы, чтобы данные не теряли логику",False
77,22,"SELECT DISTINCT – удаляет дубликаты, и оптимально для больших таблиц, так как не требует полной сортировки данных",False
78,22,"GROUP BY – группирует данные, но оптимально для удаления дубликатов в больших таблицах",False
79,22,"UNION (без ALL) – удаляет дубликаты и оптимально для больших таблиц, так как не требует полной сортировки данных",False
80,22,"ROW_NUMBER() OVER (...) – даст нумерацию дублей. Оптимально для больших таблиц, так как оконные функции позволяют избежать дополнительных операций группировки и подсчета",True
81,23,"Для этого нужен FOREIGN KEY – ограничение, которое связывает одну таблицу с другой.
Как это работает?
- FOREIGN KEY в таблице bookings ссылается на PRIMARY KEY в flights.
- Если попытаться вставить бронирование с несуществующим flight_id, PostgreSQL не позволит это сделать.
- Если удалить рейс, у которого есть бронирования, можно настроить, что делать: запретить (RESTRICT), удалить (CASCADE) или обнулить (SET NULL)",True
82,23,"Для этого нужен UNIQUE KEY – ограничение, которое запрещает дублирование значений в столбце. Это поможет избежать дублирования бронирований, и предотвратит бронирования на несуществующие рейсы. UNIQUE KEY обеспечивает уникальность значений в столбце, и свяжет таблицы.",False
83,23,"Для этого нужен CHECK – ограничение, которое проверяет выполнение условия перед вставкой данных. CHECK может использоваться для проверки условий внутри одной и другой таблицы и для связи между таблицами. Например, можно проверить, что значение столбца больше нуля и можно проверить существование рейса в другой таблице.",False
84,23,"Для этого нужен PRIMARY KEY – ограничение, которое делает столбец уникальным идентификатором каждой строки. PRIMARY KEY обеспечивает уникальность и целостность данных в одной и другой таблице и связывает таблицы между собой. Он предотвратит бронирования на несуществующие рейсы.",False
85,24,"0, потому что оператор LIKE 'Data' ищет точное совпадение строки с Data, а не подстроку",True
86,24,"1, потому что оператор LIKE 'Data' найдёт только одну строку, заканчивающуюся на Data",False
87,24,"3, потому что оператор LIKE 'Data' найдёт строки, начинающиеся на Data",False
88,24,"5, потому что оператор LIKE 'Data' найдёт все строки, содержащие подстроку Data",False
89,25,"Для этого нужен первичный ключ (PRIMARY KEY) – уникальный идентификатор записи.
Как это работает?
- PRIMARY KEY – это столбец (или несколько), который гарантированно уникален.
- В каждой таблице может быть только один первичный ключ.
- Если есть несколько кандидатов на ключ, выбираем наиболее удобный (короткий, неизменяемый)",True
90,25,"Для этого нужен уникальный ключ (UNIQUE KEY) – он обеспечивает уникальность значений в столбце и гарантирует, что столбец будет использоваться как идентификатор записи. UNIQUE KEY может быть несколько в одной таблице",False
91,25,Для этого нужен внешний ключ (FOREIGN KEY) – он связывает одну таблицу с другой и обеспечивает уникальность значений в столбце. FOREIGN KEY используется для поддержания ссылочной целостности между таблицами и рашает поставленную задачу,False
92,25,Для этого нужен индекс (INDEX) – он ускоряет поиск данных в таблице и обеспечивает уникальность значений в столбце. INDEX может быть создан на любом столбце или группе столбцов,False
93,26,"SELECT *, 
       SUM(question_count) OVER (ORDER BY topic_id , difficulty_level) AS question_total
  FROM report_questions;",True
94,26,"SELECT *, 
       SUM(question_count) OVER (ORDER BY topic_id) AS question_total
  FROM report_questions",False
95,26,"SELECT *, 
       SUM(question_count) OVER (ORDER BY difficulty_level) AS question_total
  FROM report_questions",False
96,26,"SELECT *, 
       SUM(question_count) OVER (PARTITION BY topic_id ORDER BY topic_id, difficulty_level) AS question_total
  FROM report_questions",False
97,27,"Да, LEFT JOIN всегда берёт все строки из левой таблицы (A) и добавляет к ним совпадающие строки из правой таблицы (B). Если совпадений нет, в столбцах из B будут `NULL`. Если поменять местами A и B, то теперь уже другая таблица будет ""левой"", а `NULL` появятся там, где раньше были данные",True
98,27,"Нет, результат останется тем же, так как LEFT JOIN всегда возвращает все строки из обеих таблиц. LEFT JOIN возвращает все строки левой таблицы и совпадающие строки из правой таблицы, а также выводит те по которым не было совпадения сначала из левой, а потом из правой. Только порядок строк поменяется",False
99,27,"Да, но только если в таблицах A и B есть одинаковые столбцы. Порядок таблиц в LEFT JOIN всегда имеет значение, а при наличии наличия одинаковых столбцов по которым происходит сравнение в условии после ON. Получается в одном случае справа отразится столбец правой таблицы, а после перестановки столбец левой. А так как задано, что таблицы разные, то результат изменится",False
100,27,"Нет, результат останется тем же, так как порядок таблиц в LEFT JOIN не имеет значения. Порядок таблиц в LEFT JOIN определяет, какие строки будут возвращены из левой таблицы и какие строки будут дополнены из правой таблицы. Поэтому после перестановки просто поменяется порядок столбцов, но это не считается изменением так как данные в строках не изменятся",False
101,28,"Нет, результат останется тем же, так как INNER JOIN возвращает только те строки, которые имеют совпадения в обеих таблицах. Порядок таблиц в INNER JOIN не влияет на результат, так как он просто объединяет строки, удовлетворяющие условию соединения",True
102,28,"Да, результат изменится, так как порядок таблиц в INNER JOIN определяет, какие строки будут возвращены из правой таблицы сначала и какие строки будут дополнены из левой таблицы. Поэтому INNER JOIN возвращает сначала значения из правой таблицы и потом дополняет их справа соответствующими значениями из левой таблицы. Там где соответсвий нет ставится NULL. Поэтому при смене порядка результат изменится",False
103,28,"Нет, результат останется тем же, так как INNER JOIN всегда возвращает все строки из обеих таблиц, независимо от порядка таблиц и соответствия. INNER JOIN возвращает все строки из таблиц сначала совпадающие строки из обеих таблиц",False
104,28,"Да, результат изменится, так как порядок таблиц в INNER JOIN определяет, какие строки будут возвращены из левой таблицы и какие строки будут дополнены из правой таблицы. Поэтому INNER JOIN возвращает сначала значения из левой таблицы и соответствующие значения из правой таблицы. Там где соответсвий нет ставится NULL. Поэтому при смене порядка результат изменится",False
105,29,"✅ INNER JOIN (A, B) ⇔ INNER JOIN (B, A)
✅ LEFT JOIN (A, B) ⇔ RIGHT JOIN (B, A)
✅ RIGHT JOIN (A, B) ⇔ LEFT JOIN (B, A)
✅ FULL JOIN (A, B) ⇔ FULL JOIN (B, A)
❌ LEFT JOIN (A, B) ≠ LEFT JOIN (B, A)
❌ RIGHT JOIN (A, B) ≠ RIGHT JOIN (B, A)",True
106,29,"❌ INNER JOIN (A, B) ≠ INNER JOIN (B, A)
✅ LEFT JOIN (A, B) ⇔ RIGHT JOIN (B, A)
✅ RIGHT JOIN (A, B) ⇔ LEFT JOIN (B, A)
❌ FULL JOIN (A, B) ≠ FULL JOIN (B, A)
✅ LEFT JOIN (A, B) ⇔ LEFT JOIN (B, A)
✅ RIGHT JOIN (A, B) ⇔ RIGHT JOIN (B, A)",False
107,29,"✅ INNER JOIN (A, B) ⇔ INNER JOIN (B, A)
✅ LEFT JOIN (A, B) ⇔ RIGHT JOIN (B, A)
✅ RIGHT JOIN (A, B) ⇔ LEFT JOIN (B, A)
❌ FULL JOIN (A, B) ≠ FULL JOIN (B, A)
❌ LEFT JOIN (A, B) ≠ LEFT JOIN (B, A)
❌ RIGHT JOIN (A, B) ≠ RIGHT JOIN (B, A)",False
108,29,"✅ INNER JOIN (A, B) ⇔ INNER JOIN (B, A)
✅ LEFT JOIN (A, B) ⇔ RIGHT JOIN (B, A)
❌ RIGHT JOIN (A, B) ≠ LEFT JOIN (B, A)
✅ FULL JOIN (A, B) ⇔ FULL JOIN (B, A)
❌ LEFT JOIN (A, B) ≠ LEFT JOIN (B, A)
❌ RIGHT JOIN (A, B) ≠ RIGHT JOIN (B, A)",False
109,30,"Подзапросы в PostgreSQL бывают трех видов: коррелированные, некоррелированные и вложенные.
1. Коррелированные подзапросы — зависят от данных из внешнего запроса. Выполняются для каждой строки внешнего запроса, поэтому могут быть медленными.
2. Некоррелированные подзапросы — работают независимо, их можно выполнить отдельно. Они просто возвращают данные, которые используются в основном запросе.
3. Вложенные подзапросы — это просто подзапросы внутри других запросов, безотносительно к тому, коррелированные они или нет.
💡 Важно: В официальной документации PostgreSQL чёткого разделения на такие типы нет — это скорее общепринятые термины из SQL-стандартов и литературы. Единственное, что явно упоминается в документации PostgreSQL, — это скалярные подзапросы (те, что возвращают одно значение)",True
110,30,"Подзапросы в PostgreSQL бывают двух видов: некоррелированные и скалярные.
1. Некоррелированные подзапросы — работают независимо, их можно выполнить отдельно. Они просто возвращают данные, которые используются в основном запросе.
2. Скалярные подзапросы — зависят от данных из внешнего запроса. Выполняются для каждой строки внешнего запроса, поэтому могут быть медленными.
💡 Важно: В официальной документации PostgreSQL чёткого разделения на такие типы нет — это скорее общепринятые термины из SQL-стандартов и литературы. Единственное, что явно упоминается в документации PostgreSQL, — это скалярные подзапросы",False
111,30,"Подзапросы в PostgreSQL бывают трех видов: коррелированные и скалярные.
1. Коррелированные подзапросы — зависят от данных из внешнего запроса. Выполняются для каждой строки внешнего запроса, поэтому могут быть медленными.
2. Скалярные подзапросы — работают независимо, их можно выполнить отдельно. Они просто возвращают данные, которые используются в основном запросе.
💡 Важно: В официальной документации PostgreSQL чёткого разделения на такие типы нет — это скорее общепринятые термины из SQL-стандартов и литературы. Единственное, что явно упоминается в документации PostgreSQL, — это скалярные подзапросы",False
112,30,"Подзапросы в PostgreSQL бывают двух видов: вложенные и скалярные.
1. Вложенные подзапросы — это просто подзапросы внутри других запросов.
2. Скалярные подзапросы — это подзапросы, которые возвращают одно значение.
💡 Важно: Единственное, что явно упоминается в документации PostgreSQL, — это скалярные подзапросы ",False
113,31,"Когда объединяешь крошечную таблицу с огромной, хочется, чтобы запрос работал быстро, а сервер не задыхался. Вот несколько проверенных способов:
1. Начни с маленькой таблицы – PostgreSQL любит строить планы на основе первой таблицы в JOIN, так что правильный порядок может помочь.
2. Выбирай правильный JOIN – INNER JOIN быстрее, если нужны только совпадающие строки. LEFT JOIN тянет все из левой таблицы, даже если справа ничего нет, что может быть тяжелее.
3. Фильтруй данные заранее – подзапросы, WHERE, LIMIT или CTE (WITH ... AS) помогут уменьшить объем данных перед JOIN.
4. Индексы решают всё – особенно если JOIN идёт по неуникальным колонкам. Проверь, есть ли индексы на ключевых полях.
5. Анализируй план запроса (EXPLAIN ANALYZE) – PostgreSQL покажет, где узкое место. Возможно, стоит поменять порядок JOIN, добавить индекс или переписать логику.
Главное – не бояться экспериментировать и проверять, что реально ускоряет выполнение запроса. И оптимизировать всегда на данных на проде, заранее не надо.",True
114,31,"Когда объединяешь крошечную таблицу с огромной, важно учитывать несколько факторов:
1. Используй правильный тип JOIN – например, FULL JOIN может быть медленным на больших объемах данных.
2. Убедись, что на ключевых полях есть индексы – это ускорит выполнение запроса.
3. Используй подзапросы для фильтрации данных – это поможет уменьшить объем данных перед JOIN.
4. Анализируй план запроса (EXPLAIN ANALYZE) – это поможет выявить узкие места и оптимизировать запрос.
5. Рассмотри возможность использования представлений (VIEW) – это может упростить запрос и улучшить производительность.",False
115,31,"Когда объединяешь крошечную таблицу с огромной, важно учитывать несколько факторов:
1. Используй правильный тип JOIN – например, RIGHT JOIN может быть медленным на больших объемах данных.
2. Убедись, что на ключевых полях есть индексы – это ускорит выполнение запроса.
3. Используй подзапросы для фильтрации данных – это поможет уменьшить объем данных перед JOIN.
4. Анализируй план запроса (EXPLAIN ANALYZE) – это поможет выявить узкие места и оптимизировать запрос.
5. Рассмотри возможность использования CTE (WITH ... AS) – это может упростить запрос и улучшить производительность.",False
116,31,"Когда объединяешь крошечную таблицу с огромной, важно учитывать несколько факторов:
1. Используй правильный тип JOIN – например, CROSS JOIN может быть медленным на больших объемах данных.
2. Убедись, что на ключевых полях есть индексы – это ускорит выполнение запроса.
3. Используй подзапросы для фильтрации данных – это поможет уменьшить объем данных перед JOIN.
4. Анализируй план запроса (EXPLAIN ANALYZE) – это поможет выявить узкие места и оптимизировать запрос.
5. Рассмотри возможность использования LIMIT – это может упростить запрос и улучшить производительность.",False
117,32,"Составной (он же многоколонный или многостолбцовый) индекс — это индекс, который покрывает сразу несколько колонок таблицы. Он нужен, когда часто выполняются запросы с фильтрацией (WHERE), сортировкой (ORDER BY) или JOIN, использующими несколько полей. Идеально, если индекс действительно помогает реальным запросам, а не просто создается ""на всякий случай"". 😊",True
118,32,"Составной (он же многоколонный или многостолбцовый) индекс — это индекс, который создается на основе одной колонки таблицы. Он нужен для ускорения выполнения запросов, часто использующих эту колонку в условиях фильтрации (WHERE) или сортировки (ORDER BY) или JOIN.",False
119,32,"Составной (он же многоколонный или многостолбцовый) индекс — это индекс, который создается на основе нескольких таблиц. Он нужен для ускорения выполнения запросов, использующих JOIN между этими таблицами. Порядок индексов при этом не важен",False
120,32,"Составной (он же многоколонный или многостолбцовый) индекс — это индекс, который создается на основе нескольких колонок таблицы. Он нужен для ускорения выполнения запросов, использующих эти колонки в условиях фильтрации (WHERE), сортировки (ORDER BY) или JOIN. Порядок индексов при этом не важен и он не рекомендуется для использования, так как может замедлить обновление данных.",False
121,33,"1. Используем B-tree. Потомочто он идеально подходит для точных сравнений (=) и диапазонных условий (>=, <). Это стандартный индекс, который PostgreSQL умеет эффективно использовать.
2. Какая последовательность колонок в индексе?

CREATE INDEX idx_town_time ON trip (town_from, time_out);

потому что:
- Фильтрация по town_from первой потому что это кардинально уменьшает выборку, если в базе есть тысячи разных городов.
- Фильтрация по time_out после town_from работает на оставшемся подмножестве, что даёт максимальную эффективность.

3. Стоит ли менять порядок условий в WHERE?
❌ Нет, порядок условий в запросе не влияет на использование индекса – оптимизатор PostgreSQL сам решает, как применять индекс.

Используем B-tree с индексом (town_from, time_out), и запрос начинает работать намного быстрее 🚀",True
122,33,"1. Используем B-tree. Потомочто он идеально подходит для точных сравнений (=) и диапазонных условий (>=, <). Это стандартный индекс, который PostgreSQL умеет эффективно использовать.
2. Какая последовательность колонок в индексе?

CREATE INDEX idx_time_town ON trip (time_out, town_from);

потому что:
- Фильтрация по time_out первой потому что это кардинально уменьшает выборку, если в базе есть тысячи разных временных интервалов.
- Фильтрация по town_from после time_out работает на оставшемся подмножестве, что даёт максимальную эффективность.

3. Стоит ли менять порядок условий в WHERE?
❌ Нет, порядок условий в запросе не влияет на использование индекса – оптимизатор PostgreSQL сам решает, как применять индекс.

Используем B-tree с индексом (time_out, town_from), и запрос начинает работать намного быстрее 🚀",False
123,33,"1. Используем B-tree. Потомочто он идеально подходит для точных сравнений (=) и диапазонных условий (>=, <). Это стандартный индекс, который PostgreSQL умеет эффективно использовать.
2. Какая последовательность колонок в индексе?

CREATE INDEX idx_town_time ON trip (town_from, time_out);

потому что:
- Фильтрация по town_from первой потому что это кардинально уменьшает выборку, если в базе есть тысячи разных городов.
- Фильтрация по time_out после town_from работает на оставшемся подмножестве, что даёт максимальную эффективность.

3. Стоит ли менять порядок условий в WHERE?
✅ Да лучше поменять порядок условий в запросе и заодно создать запрос в таком же порядке

Используем B-tree с индексом (town_from, time_out), и запрос начинает работать намного быстрее 🚀",False
124,33,"1. Используем BRIN. Потомочто он идеально подходит для работы с большими таблицами, где данные имеют естественный порядок, а timestamp отлично укладывается в это определение.
2. Какая последовательность колонок в индексе?

CREATE INDEX idx_time_town ON trip (time_out, town_from);

потому что:
- Фильтрация по time_out первой потому что это кардинально уменьшает выборку, если в базе есть тысячи разных временных интервалов.
- Фильтрация по town_from после time_out работает на оставшемся подмножестве, что даёт максимальную эффективность.

3. Стоит ли менять порядок условий в WHERE?
❌ Нет, порядок условий в запросе не влияет на использование индекса – оптимизатор PostgreSQL сам решает, как применять индекс.

Используем BRIN с индексом (time_out, town_from), и запрос начинает работать намного быстрее 🚀",False
125,34,"CTE (Common Table Expression) – это такой ""мини-запрос"" внутри основного запроса. Работает через WITH, создавая временную таблицу, которая существует только во время выполнения запроса.
✅ Улучшает читаемость кода – запросы становятся структурированными и понятными.
✅ Позволяет избежать дублирования логики, если один и тот же подзапрос нужен несколько раз.
✅ Упрощает разбитие сложных вычислений на отдельные шаги.
⚠️ Важно:
- CTE не всегда работает быстрее подзапросов или JOIN – зависит от конкретного случая.
- Если CTE слишком большой, лучше использовать индексированные временные таблицы или материализованные CTE (MATERIALIZED в PostgreSQL 12+)",True
126,34,"CTE (Common Table Expression) – это временная таблица, которая создается с помощью команды CREATE TEMP TABLE и существует только во время выполнения запроса.
✅ Улучшает читаемость кода – запросы становятся структурированными и понятными.
✅ Позволяет избежать дублирования логики, если один и тот же подзапрос нужен несколько раз.
✅ Упрощает разбитие сложных вычислений на отдельные шаги.
⚠️ Важно:
- CTE всегда работает быстрее подзапросов или JOIN.
- Если CTE слишком большой, лучше использовать индексированные временные таблицы.",False
127,34,"CTE (Common Table Expression) – это подзапрос, который выполняется до основного запроса и используется для создания временной таблицы, которая существует только во время выполнения запроса.
✅ Улучшает читаемость кода – запросы становятся структурированными и понятными.
✅ Позволяет избежать дублирования логики, если один и тот же подзапрос нужен несколько раз.
✅ Упрощает разбитие сложных вычислений на отдельные шаги.
⚠️ Важно:
- CTE всегда работает быстрее подзапросов или JOIN.
- Если CTE слишком большой, лучше использовать индексированные временные таблицы.",False
128,34,"CTE (Common Table Expression) – это подзапрос, который выполняется после основного запроса и используется для создания временной таблицы, которая существует только во время выполнения запроса.
✅ Улучшает читаемость кода – запросы становятся структурированными и понятными.
✅ Позволяет избежать дублирования логики, если один и тот же подзапрос нужен несколько раз.
✅ Упрощает разбитие сложных вычислений на отдельные шаги.
⚠️ Важно:
- CTE не всегда работает быстрее подзапросов или JOIN – зависит от конкретного случая.
- Если CTE слишком большой, лучше использовать индексированные временные таблицы или материализованные CTE (MATERIALIZED в PostgreSQL 12+)",False
129,35,"EXPLAIN – это инструмент для анализа запросов, который показывает, как именно PostgreSQL будет их выполнять. Он помогает понять, какие индексы используются, сколько строк сканируется и где может быть узкое место.
✅ Помогает оптимизировать запросы, находя самые затратные операции.
✅ Показывает план выполнения запроса, включая типы сканирования (Seq Scan, Index Scan, Bitmap Heap Scan).
✅ Даёт возможность оценить стоимость выполнения (cost), которая помогает выбрать лучший вариант индексации",True
130,35,"EXPLAIN – это инструмент для анализа запросов, который показывает, как именно PostgreSQL будет их выполнять. Он помогает понять, какие индексы используются, сколько строк сканируется и где может быть узкое место.
✅ Помогает оптимизировать запросы, находя самые затратные операции.
✅ Показывает реальное время выполнения каждого шага запроса, включая типы сканирования (Seq Scan, Index Scan, Bitmap Heap Scan).
❌ Не даёт возможности оценить стоимость выполнения (cost), но помогает выбрать лучший вариант индексации по времени",False
131,35,"EXPLAIN – это инструмент для анализа запросов, который показывает, как именно PostgreSQL будет их выполнять. Он помогает понять, какие индексы используются, сколько строк сканируется и где может быть узкое место.
✅ Помогает оптимизировать запросы, находя самые затратные операции.
✅ Показывает реальное время выполнения каждого шага запроса, включая типы сканирования (Seq Scan, Index Scan, Bitmap Heap Scan).
✅ Даёт возможность оценить стоимость выполнения (cost), которая помогает выбрать лучший вариант индексации",False
132,35,"EXPLAIN – это инструмент для анализа запросов, который показывает, как именно PostgreSQL будет их выполнять. Он помогает понять, какие индексы используются, сколько строк сканируется и где может быть узкое место.
✅ Помогает оптимизировать запросы, находя самые затратные операции.
✅ Показывает план выполнения запроса, не включая типы сканирования 
✅ Даёт возможность оценить стоимость выполнения (cost), которая помогает выбрать лучший вариант индексации",False
133,36,"В PostgreSQL есть три основных алгоритма соединения (JOIN):
1. Nested Loop Join (вложенные циклы)
– Работает, как вложенный FOR в коде: берём каждую строку из одной таблицы и ищем совпадения во второй.
– Эффективен для маленьких таблиц или когда на JOIN-поле есть индекс.
– Если данных много, может быть очень медленным.
2. Hash Join
– PostgreSQL строит хеш-таблицу на основе одной из таблиц (обычно меньшей), а потом проверяет соответствия по хешу.
– Подходит для больших наборов данных, но требует дополнительной памяти для хеш-таблицы.
– Работает только для соединений по `=` (равенство).
3. Merge Join (слияние)
– Требует предварительной сортировки данных в обеих таблицах.
– Может быть очень быстрым, если данные уже отсортированы.
– Хорош для больших таблиц, особенно если выполняется диапазонный JOIN (например, BETWEEN).
PostgreSQL сам решает, какой JOIN использовать",True
134,36,"В PostgreSQL есть два основных алгоритма соединения (JOIN):
1. Nested Loop Join (вложенные циклы)
– Работает, как вложенный FOR в коде: берём каждую строку из одной таблицы и ищем совпадения во второй.
– Эффективен для маленьких таблиц или когда на JOIN-поле есть индекс.
– Если данных много, может быть очень медленным.
2. Hash Join
– PostgreSQL строит хеш-таблицу на основе одной из таблиц (обычно меньшей), а потом проверяет соответствия по хешу.
– Подходит для больших наборов данных, но требует дополнительной памяти для хеш-таблицы.
– Работает для соединений с любыми видами сравнений (равенство, не точное равенство).
PostgreSQL сам решает, какой JOIN использовать",False
135,36,"В PostgreSQL есть три основных алгоритма соединения (JOIN):
1. Nested Loop Join (вложенные циклы)
– Работает, как вложенный FOR в коде: берём каждую строку из одной таблицы и ищем совпадения во второй.
– Эффективен для маленьких таблиц или когда на JOIN-поле есть индекс.
– Если данных много, может быть очень медленным.
2. Hash Join
– PostgreSQL строит хеш-таблицу на основе одной из таблиц (обычно меньшей), а потом проверяет соответствия по хешу.
– Подходит для больших наборов данных, но требует дополнительной памяти для хеш-таблицы.
– Работает только для соединений по `=` (равенство).
PostgreSQL сам решает, какой JOIN использовать",False
136,36,"В PostgreSQL есть три основных алгоритма соединения (JOIN):
1. Nested Loop Join (вложенные циклы)
– Работает, как вложенный FOR в коде: берём каждую строку из одной таблицы и ищем совпадения во второй.
– Эффективен для маленьких таблиц или когда на JOIN-поле есть индекс.
– Если данных много, может быть очень медленным.
2. Merge Join (слияние)
– Требует предварительной сортировки данных в обеих таблицах.
– Может быть очень быстрым, если данные уже отсортированы.
– Хорош для больших таблиц, особенно если выполняется диапазонный JOIN (например, BETWEEN).
PostgreSQL сам решает, какой JOIN использовать",False
137,37,"NULL, COALESCE — это функция, которая возвращает первый ненулевой аргумент. Однако если все аргументы NULL, то результат будет NULL.
Когда применять?
- Замена NULL на дефолтное значение
- Выбор первого непустого поля (например, если данные могут быть в нескольких колонках)
- Оптимизация CASE WHEN, так как COALESCE короче и читабельнее.
⚠️ Фишка: COALESCE вычисляет все аргументы, даже если первый уже не NULL. Если в аргументах есть подзапросы или тяжёлые вычисления, лучше использовать CASE WHEN для контроля",False
138,37,"NULL, COALESCE — это функция, которая возвращает последний аргумент, если все предыдущие NULL. Однако если все аргументы NULL, то результат будет NULL.
Когда применять?
- Замена NULL на дефолтное значение
- Выбор последнего непустого поля
- Оптимизация CASE WHEN, так как COALESCE короче и читабельнее.
⚠️ Фишка: COALESCE вычисляет все аргументы, даже если первый уже не NULL. Если в аргументах есть подзапросы или тяжёлые вычисления, лучше использовать CASE WHEN для контроля",False
139,37,"NULL, COALESCE — это функция, которая возвращает первый ненулевой аргумент. Однако если все аргументы NULL, то результат будет NULL.
Когда применять?
- Замена NULL на дефолтное значение
- Выбор первого непустого поля (например, если данные могут быть в нескольких колонках)
⚠️ Фишка: COALESCE вычисляет только первый ненулевой аргумент, игнорируя остальные. Это делает её более эффективной, чем CASE WHEN",False
140,37,"NULL, COALESCE — это функция, которая возвращает первый ненулевой аргумент. Однако если все аргументы NULL, то результат будет NULL.
Когда применять?
- Замена NULL на дефолтное значение
- Выбор первого непустого поля (например, если данные могут быть в нескольких колонках)
- Оптимизация CASE WHEN, так как COALESCE короче и читабельнее.
⚠️ Фишка: COALESCE вычисляет все аргументы, даже если первый уже не NULL. Если в аргументах есть подзапросы или тяжёлые вычисления, лучше использовать CASE WHEN для контроля",True
141,38,"Этот метод называется денормализация. Мы осознанно дублируем данные, чтобы ускорить выборку, жертвуя избыточностью.
Плюсы:
✅ Быстрее работают запросы без JOIN
✅ Снижается нагрузка на сервер при частых поисках рейсов
Минусы:
❌ Если аэропорт сменит название, его нужно обновлять во всех записях таблицы flights
❌ База данных становится больше из-за дублирования данных
Денормализация особенно полезна, когда у нас много чтения и мало изменений. Например, если названия аэропортов редко меняются, это хороший компромисс между скоростью и целостностью данных",True
142,38,"Этот метод называется нормализация. Мы осознанно дублируем данные, чтобы ускорить выборку, жертвуя избыточностью.
Плюсы:
✅ Быстрее работают запросы без JOIN
✅ Снижается нагрузка на сервер при частых поисках рейсов
Минусы:
❌ Если аэропорт сменит название, его нужно обновлять во всех записях таблицы flights
❌ База данных становится больше из-за дублирования данных
Нормализация особенно полезна, когда у нас много чтения и мало изменений. Например, если названия аэропортов редко меняются, это хороший компромисс между скоростью и целостностью данных",False
143,38,"Этот метод называется партиционирование. Мы осознанно дублируем данные, чтобы ускорить выборку, жертвуя избыточностью.
Плюсы:
✅ Быстрее работают запросы без JOIN
✅ Снижается нагрузка на сервер при частых поисках рейсов
Минусы:
❌ Если аэропорт сменит название, его нужно обновлять во всех записях таблицы flights
❌ База данных становится больше из-за дублирования данных
Партиционирование особенно полезно, когда у нас много изменений и мало чтения. Например, если названия аэропортов часто меняются, это хороший компромисс между скоростью и целостностью данных",False
144,38,"Этот метод называется оптимизация запроса. Мы осознанно дублируем данные, чтобы ускорить выборку, жертвуя избыточностью.
Плюсы:
✅ Быстрее работают запросы без JOIN
✅ Снижается нагрузка на сервер при частых поисках рейсов
Минусы:
❌ Если аэропорт сменит название, его нужно обновлять во всех записях таблицы flights
❌ База данных становится больше из-за дублирования данных
Оптимизация запроса особенно полезна, когда у нас много чтения и мало изменений. Например, если названия аэропортов редко меняются, это хороший компромисс между скоростью и целостностью данных",False
145,39,"Смотри на CTE Scan и Materialize:
- Если CTE действительно материализовался, в плане будет CTE Scan, а рядом — Materialize
- Если CTE используется несколько раз — будет несколько CTE Scan с одинаковыми поддеревьями
Если PostgreSQL заинлайнит CTE — он вообще исчезнет как отдельный шаг, его тело встроят в основной план",True
146,39,"CTE всегда инлайнится, потому что PostgreSQL по умолчанию стремится минимизировать избыточные вычисления
Даже если CTE используется несколько раз, его логика просто дублируется в плане, а не сохраняется отдельно
Это позволяет планировщику гибко адаптировать подзапрос под каждый конкретный контекст выполнения",False
147,39,"Материализацию легко определить по шагам Hash Join, которые часто появляются сразу после CTE
Это объясняется тем, что PostgreSQL, получив уже готовый результат CTE, может сразу использовать его в хеш-операциях
Если хеша нет, значит, скорее всего, CTE был встроен напрямую, без предварительного вычисления",False
148,39,"PostgreSQL при генерации плана указывает явную подсказку о статусе CTE в виде строки ""CTE Materialized: Yes"" или ""No""
Это встроенная внутренняя мета-информация, которая помогает точно понять, был ли подзапрос выполнен заранее или просто встроен в основной поток выполнения запроса",False
149,40,"- Плюсы:
  - результат сохраняется на диск — не надо пересчитывать каждый раз
  - быстрее обычного VIEW
  - можно вешать индексы
- Минусы:
  - сам по себе не обновляется, нужен REFRESH вручную или по крону
  - если базовая таблица поменялась, а MATERIALIZED VIEW нет — будут устаревшие данные
Так что отлично подходит для тяжёлых, редко обновляемых отчётов или агрегаций
Но за актуальностью данных придётся следить",True
150,40,"- Плюсы:
  - всегда содержит актуальные данные без дополнительного обновления
  - автоматически синхронизируется при изменении базовой таблицы
  - не требует ручного контроля
- Минусы:
  - нельзя использовать индексы
  - занимает больше памяти в оперативке
Используется там, где важна точность, а не производительность",False
151,40,"- Плюсы:
  - VIEW можно индексировать, а MATERIALIZED VIEW — нет
  - последний легче читается и отлаживается
  - быстрее в написании
- Минусы:
  - MATERIALIZED VIEW всегда считается на лету
  - не может использоваться с агрегатами
Подходит для временных данных, а не для отчётов",False
152,40,"- Плюсы:
  - оба типа VIEW обновляются автоматически при изменениях
  - нет необходимости вызывать REFRESH вручную
  - не нужно думать об актуальности
- Минусы:
  - MATERIALIZED VIEW медленнее обычного VIEW
  - нельзя строить сложные связи
Их применяют в OLTP-системах, где важна гибкость",False
153,41,"— Сначала выполню EXPLAIN ANALYZE, чтобы увидеть реальный план запроса
— Сравню оценочное и фактическое количество строк
— Если расхождение большое — сделаю ANALYZE таблицы
— Проверю, используются ли индексы
— При необходимости — перепишу запрос или добавлю расширенную статистику
— Оценю параметры конфигурации PostgreSQL, влияющие на планировщик
— При необходимости — проведу нагрузочное тестирование и посмотрю блокировки или I/O-задержки",True
154,41,"— Начну с анализа структуры таблиц и удалю неиспользуемые поля
— Выполню REINDEX, чтобы ускорить доступ
— Проверю, есть ли триггеры, замедляющие выполнение
— Использую SET enable_nestloop = off, чтобы отключить вложенные циклы
— Настрою логирование медленных запросов после оптимизации
— Добавлю VACUUM FULL для всех таблиц",False
155,41,"— Проверю, используется ли JOIN вместо подзапроса
— Заменю все JOIN на подзапросы, потому что они быстрее
— Отключу planner-оптимизации через GUC-настройки
— Перепишу запрос, исключив агрегатные функции
— Удалю индексы, если они не помогают ускорению
— Протестирую через EXPLAIN без ANALYZE",False
156,41,"— Сначала проверю размер таблиц и удалю все старые данные
— Ускорю запрос, временно отключив проверку ограничений
— Запущу CLUSTER, чтобы отсортировать данные физически
— Использую EXPLAIN BUFFERS вместо EXPLAIN ANALYZE
— Добавлю больше памяти в PostgreSQL конфиг
— Попробую заменить SELECT на COPY для ускорения чтения",False
161,43,"1. Чем заменить EXCEPT:
   Используй LEFT JOIN + IS NULL — это стабильное и хорошо масштабируемое решение:

   SELECT a.user_id  
     FROM group_a a
          LEFT JOIN group_b b
          ON a.user_id = b.user_id
    WHERE b.user_id IS NULL;

   Работает быстро, особенно если на user_id есть индексы
2. Почему EXCEPT тормозит:
   - Он материализует промежуточные результаты
   - Делает DISTINCT по умолчанию, даже если он не нужен
   - Всё это плохо масштабируется на больших объёмах, потому что требует сортировки и много памяти/CPU
3. Почему его запрещают в проде:
   - Потому что EXCEPT и INTERSECT — тяжёлые, непредсказуемые и труднооптимизируемые
   - А LEFT JOIN ... IS NULL — прозрачный, предсказуемый и дружит с индексами
Если коротко: EXCEPT — ок для анализа на ноуте или в ад-хоке, но для прода и real-time аналитики — лучше более управляемые альтернативы",True
162,43,"1. Чем заменить EXCEPT:
   Используй FULL JOIN с фильтрацией по NULL:

   SELECT a.user_id  
     FROM group_a a
          FULL JOIN group_b b
          ON a.user_id = b.user_id
    WHERE b.user_id IS NULL;

   Это может быть полезно, если тебе нужно видеть и unmatched строки из обеих таблиц
2. Почему EXCEPT тормозит:
   - Создаёт промежуточные временные структуры
   - Выполняет сортировку для уникализации
   - Плохо масштабируется при большом числе строк
3. Почему его запрещают в проде:
   - Сложно прогнозировать план запроса
   - Менее прозрачен по сравнению с JOIN
   - FULL JOIN даёт больше гибкости при отладке",False
163,43,"1. Чем заменить EXCEPT:
   Используй WHERE NOT IN — простая и понятная альтернатива:

   SELECT user_id  
     FROM group_a
    WHERE user_id NOT IN (
             SELECT user_id
               FROM group_b
         );

   Работает, но может давать неожиданные результаты при NULL
2. Почему EXCEPT тормозит:
   - Выполняет DISTINCT независимо от необходимости
   - Требует полной загрузки подзапросов в память
   - Малоэффективен при работе с большими наборами
3. Почему его запрещают в проде:
   - Поведение с NULL может быть неожиданным
   - NOT IN читается проще
   - JOIN даёт больше контроля над планом",False
164,43,"1. Чем заменить EXCEPT:
   Используй WHERE NOT EXISTS — эффективно при наличии индексов:

   SELECT a.user_id  
     FROM group_a a
    WHERE NOT EXISTS (
             SELECT 1
               FROM group_b b
              WHERE a.user_id = b.user_id
         );

2. Почему EXCEPT тормозит:
   - Требует полной материализации входных потоков
   - Выполняет сортировку и удаление дубликатов
   - Плохо распараллеливается
3. Почему его запрещают в проде:
   - Поведение зависит от конкретной версии PostgreSQL
   - EXISTS лучше масштабируется
   - JOIN-подходы чаще предпочтительны для real-time",False
